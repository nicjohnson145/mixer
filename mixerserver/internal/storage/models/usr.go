// Code generated by BobGen psql v0.15.6. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"errors"
	"fmt"

	"github.com/aarondl/opt/omit"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/dialect/psql/sm"
)

// Usr is an object representing the database table.
type Usr struct {
	Username string `db:"username,pk" json:"username" toml:"username" yaml:"username"`
	Password string `db:"password" json:"password" toml:"password" yaml:"password"`

	R usrR `db:"-" json:"-" toml:"-" yaml:"-"`
}

// UsrSlice is an alias for a slice of pointers to Usr.
// This should almost always be used instead of []Usr.
type UsrSlice []*Usr

// UsrsTable contains methods to work with the usr table
var UsrsTable = psql.NewTablex[*Usr, UsrSlice, *UsrSetter]("", "usr")

// UsrsQuery is a query on the usr table
type UsrsQuery = *psql.TableQuery[*Usr, UsrSlice, *UsrSetter]

// UsrsStmt is a prepared statment on usr
type UsrsStmt = bob.QueryStmt[*Usr, UsrSlice]

// usrR is where relationships are stored.
type usrR struct {
	UsernameDrinks DrinkSlice `db:"UsernameDrinks" json:"UsernameDrinks" toml:"UsernameDrinks" yaml:"UsernameDrinks"`
}

// UsrSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type UsrSetter struct {
	Username omit.Val[string] `db:"username,pk"`
	Password omit.Val[string] `db:"password"`
}

type usrColumnNames struct {
	Username string
	Password string
}

var UsrColumns = struct {
	Username psql.Expression
	Password psql.Expression
}{
	Username: psql.Quote("usr", "username"),
	Password: psql.Quote("usr", "password"),
}

type usrWhere[Q psql.Filterable] struct {
	Username psql.WhereMod[Q, string]
	Password psql.WhereMod[Q, string]
}

func UsrWhere[Q psql.Filterable]() usrWhere[Q] {
	return usrWhere[Q]{
		Username: psql.Where[Q, string](psql.Quote("usr", "username")),
		Password: psql.Where[Q, string](psql.Quote("usr", "password")),
	}
}

// Usrs begins a query on usr
func Usrs(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) UsrsQuery {
	return UsrsTable.Query(ctx, exec, mods...)
}

// FindUsr retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindUsr(ctx context.Context, exec bob.Executor, UsernamePK string, cols ...string) (*Usr, error) {
	if len(cols) == 0 {
		return UsrsTable.Query(
			ctx, exec,
			SelectWhere.Usrs.Username.EQ(UsernamePK),
		).One()
	}

	return UsrsTable.Query(
		ctx, exec,
		SelectWhere.Usrs.Username.EQ(UsernamePK),
		sm.Columns(UsrsTable.Columns().Only(cols...)),
	).One()
}

// UsrExists checks the presence of a single record by primary key
func UsrExists(ctx context.Context, exec bob.Executor, UsernamePK string) (bool, error) {
	return UsrsTable.Query(
		ctx, exec,
		SelectWhere.Usrs.Username.EQ(UsernamePK),
	).Exists()
}

// Update uses an executor to update the Usr
func (o *Usr) Update(ctx context.Context, exec bob.Executor, cols ...string) (int64, error) {
	rowsAff, err := UsrsTable.Update(ctx, exec, o, cols...)
	if err != nil {
		return rowsAff, err
	}

	return rowsAff, nil
}

// Delete deletes a single Usr record with an executor
func (o *Usr) Delete(ctx context.Context, exec bob.Executor) (int64, error) {
	return UsrsTable.Delete(ctx, exec, o)
}

// Reload refreshes the Usr using the executor
func (o *Usr) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := UsrsTable.Query(
		ctx, exec,
		SelectWhere.Usrs.Username.EQ(o.Username),
	).One()
	if err != nil {
		return err
	}
	o2.R = o.R
	*o = *o2

	return nil
}

func (o UsrSlice) DeleteAll(ctx context.Context, exec bob.Executor) (int64, error) {
	return UsrsTable.DeleteMany(ctx, exec, o...)
}

func (o UsrSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals UsrSetter) (int64, error) {
	rowsAff, err := UsrsTable.UpdateMany(ctx, exec, &vals, o...)
	if err != nil {
		return rowsAff, err
	}

	return rowsAff, nil
}

func (o UsrSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	var mods []bob.Mod[*dialect.SelectQuery]

	UsernamePK := make([]any, len(o))
	for i, o := range o {
		UsernamePK[i] = o.Username
	}
	mods = append(mods, sm.Where(UsrColumns.Username.In(UsernamePK...)))

	o2, err := Usrs(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	for _, old := range o {
		for _, new := range o2 {
			if new.Username != old.Username {
				continue
			}
			new.R = old.R
			*old = *new
			break
		}
	}

	return nil
}

// UsernameDrinks starts a query for related objects on drink
func (o *Usr) UsernameDrinks(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) DrinksQuery {
	return Drinks(ctx, exec, append(mods,
		sm.Where(DrinkColumns.Username.EQ(psql.Arg(o.Username))),
	)...)
}

func (os UsrSlice) UsernameDrinks(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) DrinksQuery {
	PKArgs := make([]any, 0, len(os))
	for _, o := range os {
		PKArgs = append(PKArgs, psql.ArgGroup(o.Username))
	}

	return Drinks(ctx, exec, append(mods,
		sm.Where(psql.Group(DrinkColumns.Username).In(PKArgs...)),
	)...)
}

func (o *Usr) Preload(name string, retrieved any) error {
	if o == nil {
		return nil
	}

	switch name {
	case "UsernameDrinks":
		rels, ok := retrieved.(DrinkSlice)
		if !ok {
			return fmt.Errorf("usr cannot load %T as %q", retrieved, name)
		}

		o.R.UsernameDrinks = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.UsernameUsr = o
			}
		}
		return nil
	default:
		return fmt.Errorf("usr has no relationship %q", name)
	}
}

func ThenLoadUsrUsernameDrinks(queryMods ...bob.Mod[*dialect.SelectQuery]) psql.Loader {
	return psql.Loader(func(ctx context.Context, exec bob.Executor, retrieved any) error {
		loader, isLoader := retrieved.(interface {
			LoadUsrUsernameDrinks(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
		})
		if !isLoader {
			return fmt.Errorf("object %T cannot load UsrUsernameDrinks", retrieved)
		}

		return loader.LoadUsrUsernameDrinks(ctx, exec, queryMods...)
	})
}

// LoadUsrUsernameDrinks loads the usr's UsernameDrinks into the .R struct
func (o *Usr) LoadUsrUsernameDrinks(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	related, err := o.UsernameDrinks(ctx, exec, mods...).All()
	if err != nil && !errors.Is(err, sql.ErrNoRows) {
		return err
	}

	for _, rel := range related {
		rel.R.UsernameUsr = o
	}

	o.R.UsernameDrinks = related
	return nil
}

// LoadUsrUsernameDrinks loads the usr's UsernameDrinks into the .R struct
func (os UsrSlice) LoadUsrUsernameDrinks(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	drinks, err := os.UsernameDrinks(ctx, exec, mods...).All()
	if err != nil && !errors.Is(err, sql.ErrNoRows) {
		return err
	}

	for _, o := range os {
		o.R.UsernameDrinks = nil
	}

	for _, rel := range drinks {
		for _, o := range os {
			if o.Username != rel.Username {
				continue
			}

			rel.R.UsernameUsr = o

			o.R.UsernameDrinks = append(o.R.UsernameDrinks, rel)
		}
	}

	return nil
}

func (o *Usr) InsertUsernameDrinks(ctx context.Context, exec bob.Executor, related ...*DrinkSetter) error {
	var err error

	rels := related

	for _, rel := range rels {
		rel.Username = omit.From(o.Username)
	}

	newRels, err := DrinksTable.InsertMany(ctx, exec, related...)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}
	o.R.UsernameDrinks = append(o.R.UsernameDrinks, newRels...)

	for _, rel := range newRels {
		rel.R.UsernameUsr = o
	}

	return nil
}

func (o *Usr) AttachUsernameDrinks(ctx context.Context, exec bob.Executor, related ...*Drink) error {

	for _, rel := range related {
		rel.Username = o.Username
	}

	if _, err := DrinksTable.UpdateMany(
		ctx, exec, &DrinkSetter{
			Username: omit.From(o.Username),
		}, related...,
	); err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	o.R.UsernameDrinks = append(o.R.UsernameDrinks, related...)

	for _, rel := range related {
		rel.R.UsernameUsr = o
	}

	return nil
}
