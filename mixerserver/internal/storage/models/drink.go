// Code generated by BobGen psql v0.15.6. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"errors"
	"fmt"

	"github.com/aarondl/opt/null"
	"github.com/aarondl/opt/omit"
	"github.com/aarondl/opt/omitnull"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/dialect/psql/sm"
	"github.com/stephenafamo/bob/orm"
)

// Drink is an object representing the database table.
type Drink struct {
	ID               int              `db:"id,pk" json:"id" toml:"id" yaml:"id"`
	Name             string           `db:"name" json:"name" toml:"name" yaml:"name"`
	Username         string           `db:"username" json:"username" toml:"username" yaml:"username"`
	PrimaryAlcohol   string           `db:"primary_alcohol" json:"primary_alcohol" toml:"primary_alcohol" yaml:"primary_alcohol"`
	PreferredGlass   null.Val[string] `db:"preferred_glass" json:"preferred_glass,omitempty" toml:"preferred_glass" yaml:"preferred_glass,omitempty"`
	Ingredients      string           `db:"ingredients" json:"ingredients" toml:"ingredients" yaml:"ingredients"`
	Instructions     null.Val[string] `db:"instructions" json:"instructions,omitempty" toml:"instructions" yaml:"instructions,omitempty"`
	Notes            null.Val[string] `db:"notes" json:"notes,omitempty" toml:"notes" yaml:"notes,omitempty"`
	Publicity        int              `db:"publicity" json:"publicity" toml:"publicity" yaml:"publicity"`
	UnderDevelopment bool             `db:"under_development" json:"under_development" toml:"under_development" yaml:"under_development"`
	Tags             null.Val[string] `db:"tags" json:"tags,omitempty" toml:"tags" yaml:"tags,omitempty"`
	Favorite         bool             `db:"favorite" json:"favorite" toml:"favorite" yaml:"favorite"`

	R drinkR `db:"-" json:"-" toml:"-" yaml:"-"`
}

// DrinkSlice is an alias for a slice of pointers to Drink.
// This should almost always be used instead of []Drink.
type DrinkSlice []*Drink

// DrinksTable contains methods to work with the drink table
var DrinksTable = psql.NewTablex[*Drink, DrinkSlice, *DrinkSetter]("", "drink")

// DrinksQuery is a query on the drink table
type DrinksQuery = *psql.TableQuery[*Drink, DrinkSlice, *DrinkSetter]

// DrinksStmt is a prepared statment on drink
type DrinksStmt = bob.QueryStmt[*Drink, DrinkSlice]

// drinkR is where relationships are stored.
type drinkR struct {
	UsernameUsr *Usr `db:"UsernameUsr" json:"UsernameUsr" toml:"UsernameUsr" yaml:"UsernameUsr"`
}

// DrinkSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type DrinkSetter struct {
	ID               omit.Val[int]        `db:"id,pk"`
	Name             omit.Val[string]     `db:"name"`
	Username         omit.Val[string]     `db:"username"`
	PrimaryAlcohol   omit.Val[string]     `db:"primary_alcohol"`
	PreferredGlass   omitnull.Val[string] `db:"preferred_glass"`
	Ingredients      omit.Val[string]     `db:"ingredients"`
	Instructions     omitnull.Val[string] `db:"instructions"`
	Notes            omitnull.Val[string] `db:"notes"`
	Publicity        omit.Val[int]        `db:"publicity"`
	UnderDevelopment omit.Val[bool]       `db:"under_development"`
	Tags             omitnull.Val[string] `db:"tags"`
	Favorite         omit.Val[bool]       `db:"favorite"`
}

type drinkColumnNames struct {
	ID               string
	Name             string
	Username         string
	PrimaryAlcohol   string
	PreferredGlass   string
	Ingredients      string
	Instructions     string
	Notes            string
	Publicity        string
	UnderDevelopment string
	Tags             string
	Favorite         string
}

var DrinkColumns = struct {
	ID               psql.Expression
	Name             psql.Expression
	Username         psql.Expression
	PrimaryAlcohol   psql.Expression
	PreferredGlass   psql.Expression
	Ingredients      psql.Expression
	Instructions     psql.Expression
	Notes            psql.Expression
	Publicity        psql.Expression
	UnderDevelopment psql.Expression
	Tags             psql.Expression
	Favorite         psql.Expression
}{
	ID:               psql.Quote("drink", "id"),
	Name:             psql.Quote("drink", "name"),
	Username:         psql.Quote("drink", "username"),
	PrimaryAlcohol:   psql.Quote("drink", "primary_alcohol"),
	PreferredGlass:   psql.Quote("drink", "preferred_glass"),
	Ingredients:      psql.Quote("drink", "ingredients"),
	Instructions:     psql.Quote("drink", "instructions"),
	Notes:            psql.Quote("drink", "notes"),
	Publicity:        psql.Quote("drink", "publicity"),
	UnderDevelopment: psql.Quote("drink", "under_development"),
	Tags:             psql.Quote("drink", "tags"),
	Favorite:         psql.Quote("drink", "favorite"),
}

type drinkWhere[Q psql.Filterable] struct {
	ID               psql.WhereMod[Q, int]
	Name             psql.WhereMod[Q, string]
	Username         psql.WhereMod[Q, string]
	PrimaryAlcohol   psql.WhereMod[Q, string]
	PreferredGlass   psql.WhereNullMod[Q, string]
	Ingredients      psql.WhereMod[Q, string]
	Instructions     psql.WhereNullMod[Q, string]
	Notes            psql.WhereNullMod[Q, string]
	Publicity        psql.WhereMod[Q, int]
	UnderDevelopment psql.WhereMod[Q, bool]
	Tags             psql.WhereNullMod[Q, string]
	Favorite         psql.WhereMod[Q, bool]
}

func DrinkWhere[Q psql.Filterable]() drinkWhere[Q] {
	return drinkWhere[Q]{
		ID:               psql.Where[Q, int](psql.Quote("drink", "id")),
		Name:             psql.Where[Q, string](psql.Quote("drink", "name")),
		Username:         psql.Where[Q, string](psql.Quote("drink", "username")),
		PrimaryAlcohol:   psql.Where[Q, string](psql.Quote("drink", "primary_alcohol")),
		PreferredGlass:   psql.WhereNull[Q, string](psql.Quote("drink", "preferred_glass")),
		Ingredients:      psql.Where[Q, string](psql.Quote("drink", "ingredients")),
		Instructions:     psql.WhereNull[Q, string](psql.Quote("drink", "instructions")),
		Notes:            psql.WhereNull[Q, string](psql.Quote("drink", "notes")),
		Publicity:        psql.Where[Q, int](psql.Quote("drink", "publicity")),
		UnderDevelopment: psql.Where[Q, bool](psql.Quote("drink", "under_development")),
		Tags:             psql.WhereNull[Q, string](psql.Quote("drink", "tags")),
		Favorite:         psql.Where[Q, bool](psql.Quote("drink", "favorite")),
	}
}

// Drinks begins a query on drink
func Drinks(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) DrinksQuery {
	return DrinksTable.Query(ctx, exec, mods...)
}

// FindDrink retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindDrink(ctx context.Context, exec bob.Executor, IDPK int, cols ...string) (*Drink, error) {
	if len(cols) == 0 {
		return DrinksTable.Query(
			ctx, exec,
			SelectWhere.Drinks.ID.EQ(IDPK),
		).One()
	}

	return DrinksTable.Query(
		ctx, exec,
		SelectWhere.Drinks.ID.EQ(IDPK),
		sm.Columns(DrinksTable.Columns().Only(cols...)),
	).One()
}

// DrinkExists checks the presence of a single record by primary key
func DrinkExists(ctx context.Context, exec bob.Executor, IDPK int) (bool, error) {
	return DrinksTable.Query(
		ctx, exec,
		SelectWhere.Drinks.ID.EQ(IDPK),
	).Exists()
}

// Update uses an executor to update the Drink
func (o *Drink) Update(ctx context.Context, exec bob.Executor, cols ...string) (int64, error) {
	rowsAff, err := DrinksTable.Update(ctx, exec, o, cols...)
	if err != nil {
		return rowsAff, err
	}

	return rowsAff, nil
}

// Delete deletes a single Drink record with an executor
func (o *Drink) Delete(ctx context.Context, exec bob.Executor) (int64, error) {
	return DrinksTable.Delete(ctx, exec, o)
}

// Reload refreshes the Drink using the executor
func (o *Drink) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := DrinksTable.Query(
		ctx, exec,
		SelectWhere.Drinks.ID.EQ(o.ID),
	).One()
	if err != nil {
		return err
	}
	o2.R = o.R
	*o = *o2

	return nil
}

func (o DrinkSlice) DeleteAll(ctx context.Context, exec bob.Executor) (int64, error) {
	return DrinksTable.DeleteMany(ctx, exec, o...)
}

func (o DrinkSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals DrinkSetter) (int64, error) {
	rowsAff, err := DrinksTable.UpdateMany(ctx, exec, &vals, o...)
	if err != nil {
		return rowsAff, err
	}

	return rowsAff, nil
}

func (o DrinkSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	var mods []bob.Mod[*dialect.SelectQuery]

	IDPK := make([]any, len(o))
	for i, o := range o {
		IDPK[i] = o.ID
	}
	mods = append(mods, sm.Where(DrinkColumns.ID.In(IDPK...)))

	o2, err := Drinks(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	for _, old := range o {
		for _, new := range o2 {
			if new.ID != old.ID {
				continue
			}
			new.R = old.R
			*old = *new
			break
		}
	}

	return nil
}

// UsernameUsr starts a query for related objects on usr
func (o *Drink) UsernameUsr(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) UsrsQuery {
	return Usrs(ctx, exec, append(mods,
		sm.Where(UsrColumns.Username.EQ(psql.Arg(o.Username))),
	)...)
}

func (os DrinkSlice) UsernameUsr(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) UsrsQuery {
	PKArgs := make([]any, 0, len(os))
	for _, o := range os {
		PKArgs = append(PKArgs, psql.ArgGroup(o.Username))
	}

	return Usrs(ctx, exec, append(mods,
		sm.Where(psql.Group(UsrColumns.Username).In(PKArgs...)),
	)...)
}

func (o *Drink) Preload(name string, retrieved any) error {
	if o == nil {
		return nil
	}

	switch name {
	case "UsernameUsr":
		rel, ok := retrieved.(*Usr)
		if !ok {
			return fmt.Errorf("drink cannot load %T as %q", retrieved, name)
		}

		o.R.UsernameUsr = rel

		if rel != nil {
			rel.R.UsernameDrinks = DrinkSlice{o}
		}
		return nil
	default:
		return fmt.Errorf("drink has no relationship %q", name)
	}
}

func PreloadDrinkUsernameUsr(opts ...psql.PreloadOption) psql.Preloader {
	return psql.Preload[*Usr, UsrSlice](orm.Relationship{
		Name: "UsernameUsr",
		Sides: []orm.RelSide{
			{
				From:   "drink",
				To:     TableNames.Usrs,
				ToExpr: UsrsTable.Name,
				FromColumns: []string{
					ColumnNames.Drinks.Username,
				},
				ToColumns: []string{
					ColumnNames.Usrs.Username,
				},
			},
		},
	}, UsrsTable.Columns().Names(), opts...)
}

func ThenLoadDrinkUsernameUsr(queryMods ...bob.Mod[*dialect.SelectQuery]) psql.Loader {
	return psql.Loader(func(ctx context.Context, exec bob.Executor, retrieved any) error {
		loader, isLoader := retrieved.(interface {
			LoadDrinkUsernameUsr(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
		})
		if !isLoader {
			return fmt.Errorf("object %T cannot load DrinkUsernameUsr", retrieved)
		}

		return loader.LoadDrinkUsernameUsr(ctx, exec, queryMods...)
	})
}

// LoadDrinkUsernameUsr loads the drink's UsernameUsr into the .R struct
func (o *Drink) LoadDrinkUsernameUsr(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	related, err := o.UsernameUsr(ctx, exec, mods...).One()
	if err != nil && !errors.Is(err, sql.ErrNoRows) {
		return err
	}

	related.R.UsernameDrinks = DrinkSlice{o}

	o.R.UsernameUsr = related
	return nil
}

// LoadDrinkUsernameUsr loads the drink's UsernameUsr into the .R struct
func (os DrinkSlice) LoadDrinkUsernameUsr(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	usrs, err := os.UsernameUsr(ctx, exec, mods...).All()
	if err != nil && !errors.Is(err, sql.ErrNoRows) {
		return err
	}

	for _, rel := range usrs {
		for _, o := range os {
			if o.Username != rel.Username {
				continue
			}

			rel.R.UsernameDrinks = append(rel.R.UsernameDrinks, o)

			o.R.UsernameUsr = rel
			break
		}
	}

	return nil
}

func (o *Drink) InsertUsernameUsr(ctx context.Context, exec bob.Executor, related *UsrSetter) error {
	rel, err := UsrsTable.Insert(ctx, exec, related)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}
	o.R.UsernameUsr = rel

	o.Username = rel.Username

	o.R.UsernameUsr.R.UsernameDrinks = DrinkSlice{o}

	return nil
}

func (o *Drink) AttachUsernameUsr(ctx context.Context, exec bob.Executor, rel *Usr) error {
	var err error

	o.Username = rel.Username

	_, err = rel.Update(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}
	o.R.UsernameUsr = rel

	rel.R.UsernameDrinks = append(rel.R.UsernameDrinks, o)

	return nil
}
