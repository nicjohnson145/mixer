// Code generated by BobGen psql v0.15.6. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package factory

import (
	"context"
	"strings"

	"github.com/aarondl/opt/null"
	"github.com/jaswdr/faker"
	models "github.com/nicjohnson145/mixer/mixerserver/internal/storage/models"
)

type factory struct {
	baseDrinkMods          DrinkModSlice
	baseMixerMigrationMods MixerMigrationModSlice
	baseUsrMods            UsrModSlice
	baseUsrSettingMods     UsrSettingModSlice
}

func New() *factory {
	return &factory{}
}

func (f *factory) NewDrink(mods ...DrinkMod) *DrinkTemplate {
	o := &DrinkTemplate{f: f}

	if f != nil {
		f.baseDrinkMods.Apply(o)
	}

	DrinkModSlice(mods).Apply(o)

	return o
}

func (f *factory) NewMixerMigration(mods ...MixerMigrationMod) *MixerMigrationTemplate {
	o := &MixerMigrationTemplate{f: f}

	if f != nil {
		f.baseMixerMigrationMods.Apply(o)
	}

	MixerMigrationModSlice(mods).Apply(o)

	return o
}

func (f *factory) NewUsr(mods ...UsrMod) *UsrTemplate {
	o := &UsrTemplate{f: f}

	if f != nil {
		f.baseUsrMods.Apply(o)
	}

	UsrModSlice(mods).Apply(o)

	return o
}

func (f *factory) NewUsrSetting(mods ...UsrSettingMod) *UsrSettingTemplate {
	o := &UsrSettingTemplate{f: f}

	if f != nil {
		f.baseUsrSettingMods.Apply(o)
	}

	UsrSettingModSlice(mods).Apply(o)

	return o
}

func (f *factory) ClearBaseDrinkMods() {
	f.baseDrinkMods = nil
}

func (f *factory) AddBaseDrinkMod(mods ...DrinkMod) {
	f.baseDrinkMods = append(f.baseDrinkMods, mods...)
}

func (f *factory) ClearBaseMixerMigrationMods() {
	f.baseMixerMigrationMods = nil
}

func (f *factory) AddBaseMixerMigrationMod(mods ...MixerMigrationMod) {
	f.baseMixerMigrationMods = append(f.baseMixerMigrationMods, mods...)
}

func (f *factory) ClearBaseUsrMods() {
	f.baseUsrMods = nil
}

func (f *factory) AddBaseUsrMod(mods ...UsrMod) {
	f.baseUsrMods = append(f.baseUsrMods, mods...)
}

func (f *factory) ClearBaseUsrSettingMods() {
	f.baseUsrSettingMods = nil
}

func (f *factory) AddBaseUsrSettingMod(mods ...UsrSettingMod) {
	f.baseUsrSettingMods = append(f.baseUsrSettingMods, mods...)
}

type contextKey string

var (
	drinkCtx          = newContextual[*models.Drink]("drink")
	mixerMigrationCtx = newContextual[*models.MixerMigration]("mixerMigration")
	usrCtx            = newContextual[*models.Usr]("usr")
	usrSettingCtx     = newContextual[*models.UsrSetting]("usrSetting")
)

type contextual[V any] struct {
	key contextKey
}

// This could be weird because of type inference not handling `K` due to `V` having to be manual.
func newContextual[V any](key string) contextual[V] {
	return contextual[V]{key: contextKey(key)}
}

func (k contextual[V]) WithValue(ctx context.Context, val V) context.Context {
	return context.WithValue(ctx, k.key, val)
}

func (k contextual[V]) Value(ctx context.Context) (V, bool) {
	v, ok := ctx.Value(k.key).(V)
	return v, ok
}

var defaultFaker = faker.New()

// random returns a random value for the given type, using the faker
// * If the given faker is nil, the default faker is used
// * The zero value is returned if the type cannot be handled
func random[T any](f *faker.Faker) T {
	if f == nil {
		f = &defaultFaker
	}

	var val T
	switch any(val).(type) {
	default:
		return val
	case string:
		return any(string(strings.Join(f.Lorem().Words(5), " "))).(T)

	case bool:
		return any(bool(f.BoolWithChance(50))).(T)

	case int:
		return any(int(f.Int())).(T)

	case int64:
		return val

	}
}

// randomNull is like [Random], but for null types
func randomNull[T any](f *faker.Faker) null.Val[T] {
	return null.From(random[T](f))
}
