// Code generated by BobGen psql v0.15.6. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"

	"github.com/aarondl/opt/omit"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/dialect/psql/sm"
)

// UsrSetting is an object representing the database table.
type UsrSetting struct {
	Username string `db:"username,pk" json:"username" toml:"username" yaml:"username"`
	Key      string `db:"key,pk" json:"key" toml:"key" yaml:"key"`
	Value    string `db:"value" json:"value" toml:"value" yaml:"value"`
}

// UsrSettingSlice is an alias for a slice of pointers to UsrSetting.
// This should almost always be used instead of []UsrSetting.
type UsrSettingSlice []*UsrSetting

// UsrSettingsTable contains methods to work with the usr_setting table
var UsrSettingsTable = psql.NewTablex[*UsrSetting, UsrSettingSlice, *UsrSettingSetter]("", "usr_setting")

// UsrSettingsQuery is a query on the usr_setting table
type UsrSettingsQuery = *psql.TableQuery[*UsrSetting, UsrSettingSlice, *UsrSettingSetter]

// UsrSettingsStmt is a prepared statment on usr_setting
type UsrSettingsStmt = bob.QueryStmt[*UsrSetting, UsrSettingSlice]

// UsrSettingSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type UsrSettingSetter struct {
	Username omit.Val[string] `db:"username,pk"`
	Key      omit.Val[string] `db:"key,pk"`
	Value    omit.Val[string] `db:"value"`
}

type usrSettingColumnNames struct {
	Username string
	Key      string
	Value    string
}

var UsrSettingColumns = struct {
	Username psql.Expression
	Key      psql.Expression
	Value    psql.Expression
}{
	Username: psql.Quote("usr_setting", "username"),
	Key:      psql.Quote("usr_setting", "key"),
	Value:    psql.Quote("usr_setting", "value"),
}

type usrSettingWhere[Q psql.Filterable] struct {
	Username psql.WhereMod[Q, string]
	Key      psql.WhereMod[Q, string]
	Value    psql.WhereMod[Q, string]
}

func UsrSettingWhere[Q psql.Filterable]() usrSettingWhere[Q] {
	return usrSettingWhere[Q]{
		Username: psql.Where[Q, string](psql.Quote("usr_setting", "username")),
		Key:      psql.Where[Q, string](psql.Quote("usr_setting", "key")),
		Value:    psql.Where[Q, string](psql.Quote("usr_setting", "value")),
	}
}

// UsrSettings begins a query on usr_setting
func UsrSettings(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) UsrSettingsQuery {
	return UsrSettingsTable.Query(ctx, exec, mods...)
}

// FindUsrSetting retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindUsrSetting(ctx context.Context, exec bob.Executor, KeyPK string, UsernamePK string, cols ...string) (*UsrSetting, error) {
	if len(cols) == 0 {
		return UsrSettingsTable.Query(
			ctx, exec,
			SelectWhere.UsrSettings.Key.EQ(KeyPK),
			SelectWhere.UsrSettings.Username.EQ(UsernamePK),
		).One()
	}

	return UsrSettingsTable.Query(
		ctx, exec,
		SelectWhere.UsrSettings.Key.EQ(KeyPK),
		SelectWhere.UsrSettings.Username.EQ(UsernamePK),
		sm.Columns(UsrSettingsTable.Columns().Only(cols...)),
	).One()
}

// UsrSettingExists checks the presence of a single record by primary key
func UsrSettingExists(ctx context.Context, exec bob.Executor, KeyPK string, UsernamePK string) (bool, error) {
	return UsrSettingsTable.Query(
		ctx, exec,
		SelectWhere.UsrSettings.Key.EQ(KeyPK),
		SelectWhere.UsrSettings.Username.EQ(UsernamePK),
	).Exists()
}

// Update uses an executor to update the UsrSetting
func (o *UsrSetting) Update(ctx context.Context, exec bob.Executor, cols ...string) (int64, error) {
	rowsAff, err := UsrSettingsTable.Update(ctx, exec, o, cols...)
	if err != nil {
		return rowsAff, err
	}

	return rowsAff, nil
}

// Delete deletes a single UsrSetting record with an executor
func (o *UsrSetting) Delete(ctx context.Context, exec bob.Executor) (int64, error) {
	return UsrSettingsTable.Delete(ctx, exec, o)
}

// Reload refreshes the UsrSetting using the executor
func (o *UsrSetting) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := UsrSettingsTable.Query(
		ctx, exec,
		SelectWhere.UsrSettings.Key.EQ(o.Key),
		SelectWhere.UsrSettings.Username.EQ(o.Username),
	).One()
	if err != nil {
		return err
	}

	*o = *o2

	return nil
}

func (o UsrSettingSlice) DeleteAll(ctx context.Context, exec bob.Executor) (int64, error) {
	return UsrSettingsTable.DeleteMany(ctx, exec, o...)
}

func (o UsrSettingSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals UsrSettingSetter) (int64, error) {
	rowsAff, err := UsrSettingsTable.UpdateMany(ctx, exec, &vals, o...)
	if err != nil {
		return rowsAff, err
	}

	return rowsAff, nil
}

func (o UsrSettingSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	var mods []bob.Mod[*dialect.SelectQuery]

	KeyPK := make([]any, len(o))
	for i, o := range o {
		KeyPK[i] = o.Key
	}
	mods = append(mods, sm.Where(UsrSettingColumns.Key.In(KeyPK...)))

	UsernamePK := make([]any, len(o))
	for i, o := range o {
		UsernamePK[i] = o.Username
	}
	mods = append(mods, sm.Where(UsrSettingColumns.Username.In(UsernamePK...)))

	o2, err := UsrSettings(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	for _, old := range o {
		for _, new := range o2 {
			if new.Key != old.Key {
				continue
			}
			if new.Username != old.Username {
				continue
			}

			*old = *new
			break
		}
	}

	return nil
}
