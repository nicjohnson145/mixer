// Code generated by BobGen psql v0.15.6. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"errors"
	"fmt"

	"github.com/aarondl/opt/omit"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/dialect/psql/sm"
	"github.com/stephenafamo/bob/orm"
)

// UsrSetting is an object representing the database table.
type UsrSetting struct {
	Username string `db:"username,pk" json:"username" toml:"username" yaml:"username"`
	Key      string `db:"key,pk" json:"key" toml:"key" yaml:"key"`
	Value    string `db:"value" json:"value" toml:"value" yaml:"value"`

	R usrSettingR `db:"-" json:"-" toml:"-" yaml:"-"`
}

// UsrSettingSlice is an alias for a slice of pointers to UsrSetting.
// This should almost always be used instead of []UsrSetting.
type UsrSettingSlice []*UsrSetting

// UsrSettingsTable contains methods to work with the usr_setting table
var UsrSettingsTable = psql.NewTablex[*UsrSetting, UsrSettingSlice, *UsrSettingSetter]("", "usr_setting")

// UsrSettingsQuery is a query on the usr_setting table
type UsrSettingsQuery = *psql.TableQuery[*UsrSetting, UsrSettingSlice, *UsrSettingSetter]

// UsrSettingsStmt is a prepared statment on usr_setting
type UsrSettingsStmt = bob.QueryStmt[*UsrSetting, UsrSettingSlice]

// usrSettingR is where relationships are stored.
type usrSettingR struct {
	UsernameUsr *Usr `db:"UsernameUsr" json:"UsernameUsr" toml:"UsernameUsr" yaml:"UsernameUsr"`
}

// UsrSettingSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type UsrSettingSetter struct {
	Username omit.Val[string] `db:"username,pk"`
	Key      omit.Val[string] `db:"key,pk"`
	Value    omit.Val[string] `db:"value"`
}

type usrSettingColumnNames struct {
	Username string
	Key      string
	Value    string
}

var UsrSettingColumns = struct {
	Username psql.Expression
	Key      psql.Expression
	Value    psql.Expression
}{
	Username: psql.Quote("usr_setting", "username"),
	Key:      psql.Quote("usr_setting", "key"),
	Value:    psql.Quote("usr_setting", "value"),
}

type usrSettingWhere[Q psql.Filterable] struct {
	Username psql.WhereMod[Q, string]
	Key      psql.WhereMod[Q, string]
	Value    psql.WhereMod[Q, string]
}

func UsrSettingWhere[Q psql.Filterable]() usrSettingWhere[Q] {
	return usrSettingWhere[Q]{
		Username: psql.Where[Q, string](psql.Quote("usr_setting", "username")),
		Key:      psql.Where[Q, string](psql.Quote("usr_setting", "key")),
		Value:    psql.Where[Q, string](psql.Quote("usr_setting", "value")),
	}
}

// UsrSettings begins a query on usr_setting
func UsrSettings(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) UsrSettingsQuery {
	return UsrSettingsTable.Query(ctx, exec, mods...)
}

// FindUsrSetting retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindUsrSetting(ctx context.Context, exec bob.Executor, KeyPK string, UsernamePK string, cols ...string) (*UsrSetting, error) {
	if len(cols) == 0 {
		return UsrSettingsTable.Query(
			ctx, exec,
			SelectWhere.UsrSettings.Key.EQ(KeyPK),
			SelectWhere.UsrSettings.Username.EQ(UsernamePK),
		).One()
	}

	return UsrSettingsTable.Query(
		ctx, exec,
		SelectWhere.UsrSettings.Key.EQ(KeyPK),
		SelectWhere.UsrSettings.Username.EQ(UsernamePK),
		sm.Columns(UsrSettingsTable.Columns().Only(cols...)),
	).One()
}

// UsrSettingExists checks the presence of a single record by primary key
func UsrSettingExists(ctx context.Context, exec bob.Executor, KeyPK string, UsernamePK string) (bool, error) {
	return UsrSettingsTable.Query(
		ctx, exec,
		SelectWhere.UsrSettings.Key.EQ(KeyPK),
		SelectWhere.UsrSettings.Username.EQ(UsernamePK),
	).Exists()
}

// Update uses an executor to update the UsrSetting
func (o *UsrSetting) Update(ctx context.Context, exec bob.Executor, cols ...string) (int64, error) {
	rowsAff, err := UsrSettingsTable.Update(ctx, exec, o, cols...)
	if err != nil {
		return rowsAff, err
	}

	return rowsAff, nil
}

// Delete deletes a single UsrSetting record with an executor
func (o *UsrSetting) Delete(ctx context.Context, exec bob.Executor) (int64, error) {
	return UsrSettingsTable.Delete(ctx, exec, o)
}

// Reload refreshes the UsrSetting using the executor
func (o *UsrSetting) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := UsrSettingsTable.Query(
		ctx, exec,
		SelectWhere.UsrSettings.Key.EQ(o.Key),
		SelectWhere.UsrSettings.Username.EQ(o.Username),
	).One()
	if err != nil {
		return err
	}
	o2.R = o.R
	*o = *o2

	return nil
}

func (o UsrSettingSlice) DeleteAll(ctx context.Context, exec bob.Executor) (int64, error) {
	return UsrSettingsTable.DeleteMany(ctx, exec, o...)
}

func (o UsrSettingSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals UsrSettingSetter) (int64, error) {
	rowsAff, err := UsrSettingsTable.UpdateMany(ctx, exec, &vals, o...)
	if err != nil {
		return rowsAff, err
	}

	return rowsAff, nil
}

func (o UsrSettingSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	var mods []bob.Mod[*dialect.SelectQuery]

	KeyPK := make([]any, len(o))
	for i, o := range o {
		KeyPK[i] = o.Key
	}
	mods = append(mods, sm.Where(UsrSettingColumns.Key.In(KeyPK...)))

	UsernamePK := make([]any, len(o))
	for i, o := range o {
		UsernamePK[i] = o.Username
	}
	mods = append(mods, sm.Where(UsrSettingColumns.Username.In(UsernamePK...)))

	o2, err := UsrSettings(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	for _, old := range o {
		for _, new := range o2 {
			if new.Key != old.Key {
				continue
			}
			if new.Username != old.Username {
				continue
			}
			new.R = old.R
			*old = *new
			break
		}
	}

	return nil
}

// UsernameUsr starts a query for related objects on usr
func (o *UsrSetting) UsernameUsr(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) UsrsQuery {
	return Usrs(ctx, exec, append(mods,
		sm.Where(UsrColumns.Username.EQ(psql.Arg(o.Username))),
	)...)
}

func (os UsrSettingSlice) UsernameUsr(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) UsrsQuery {
	PKArgs := make([]any, 0, len(os))
	for _, o := range os {
		PKArgs = append(PKArgs, psql.ArgGroup(o.Username))
	}

	return Usrs(ctx, exec, append(mods,
		sm.Where(psql.Group(UsrColumns.Username).In(PKArgs...)),
	)...)
}

func (o *UsrSetting) Preload(name string, retrieved any) error {
	if o == nil {
		return nil
	}

	switch name {
	case "UsernameUsr":
		rel, ok := retrieved.(*Usr)
		if !ok {
			return fmt.Errorf("usrSetting cannot load %T as %q", retrieved, name)
		}

		o.R.UsernameUsr = rel

		if rel != nil {
			rel.R.UsernameUsrSettings = UsrSettingSlice{o}
		}
		return nil
	default:
		return fmt.Errorf("usrSetting has no relationship %q", name)
	}
}

func PreloadUsrSettingUsernameUsr(opts ...psql.PreloadOption) psql.Preloader {
	return psql.Preload[*Usr, UsrSlice](orm.Relationship{
		Name: "UsernameUsr",
		Sides: []orm.RelSide{
			{
				From:   "usr_setting",
				To:     TableNames.Usrs,
				ToExpr: UsrsTable.Name,
				FromColumns: []string{
					ColumnNames.UsrSettings.Username,
				},
				ToColumns: []string{
					ColumnNames.Usrs.Username,
				},
			},
		},
	}, UsrsTable.Columns().Names(), opts...)
}

func ThenLoadUsrSettingUsernameUsr(queryMods ...bob.Mod[*dialect.SelectQuery]) psql.Loader {
	return psql.Loader(func(ctx context.Context, exec bob.Executor, retrieved any) error {
		loader, isLoader := retrieved.(interface {
			LoadUsrSettingUsernameUsr(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
		})
		if !isLoader {
			return fmt.Errorf("object %T cannot load UsrSettingUsernameUsr", retrieved)
		}

		return loader.LoadUsrSettingUsernameUsr(ctx, exec, queryMods...)
	})
}

// LoadUsrSettingUsernameUsr loads the usrSetting's UsernameUsr into the .R struct
func (o *UsrSetting) LoadUsrSettingUsernameUsr(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	related, err := o.UsernameUsr(ctx, exec, mods...).One()
	if err != nil && !errors.Is(err, sql.ErrNoRows) {
		return err
	}

	related.R.UsernameUsrSettings = UsrSettingSlice{o}

	o.R.UsernameUsr = related
	return nil
}

// LoadUsrSettingUsernameUsr loads the usrSetting's UsernameUsr into the .R struct
func (os UsrSettingSlice) LoadUsrSettingUsernameUsr(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	usrs, err := os.UsernameUsr(ctx, exec, mods...).All()
	if err != nil && !errors.Is(err, sql.ErrNoRows) {
		return err
	}

	for _, rel := range usrs {
		for _, o := range os {
			if o.Username != rel.Username {
				continue
			}

			rel.R.UsernameUsrSettings = append(rel.R.UsernameUsrSettings, o)

			o.R.UsernameUsr = rel
			break
		}
	}

	return nil
}

func (o *UsrSetting) InsertUsernameUsr(ctx context.Context, exec bob.Executor, related *UsrSetter) error {
	rel, err := UsrsTable.Insert(ctx, exec, related)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}
	o.R.UsernameUsr = rel

	o.Username = rel.Username

	o.R.UsernameUsr.R.UsernameUsrSettings = UsrSettingSlice{o}

	return nil
}

func (o *UsrSetting) AttachUsernameUsr(ctx context.Context, exec bob.Executor, rel *Usr) error {
	var err error

	o.Username = rel.Username

	_, err = rel.Update(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}
	o.R.UsernameUsr = rel

	rel.R.UsernameUsrSettings = append(rel.R.UsernameUsrSettings, o)

	return nil
}
